# ТВ-32 Михайленко Роман Практична робота 2
## Завдання 1
Було використано стандартні бібліотеки time.h для отримання типу даних
time_t та limits.h для отримання констант максимальних значень.   
Для 64 бітних систем time_t відповідає типу long long, а максимумом є LLONG_MAX;  
Для 32 бітних систем time_t відповідає типу int, а максимумом є INT_MAX;  
Програма виводить відповідні дані з використанням функції ctime() що переводить число в строку часу.      
**Але** я стикнувся з цікавим багом в моїй системі, функія ctime() не може коректно обробити значення
більші за приблизно LLONG_MAX/137, замість результату повертає null.
![task1.png](practise2/images/task1.png)
Ознайомившись з поведінкою пам'яті, можна зробити висновок, що вона є стандартною.

## Завдання 2
Було написано невелику програму з створенням ініціалізованих або не ініціалізованих  
масивів відносно великого розміру всередині та поза функцією для дослідження сегментів пам'яті.  
![task21.png](practise2/images/task21.png)
Дослідження стандартного hello world.  

![task22.png](practise2/images/task22.png)
При об'яві неініціалізованого масиву поза функцією можемо помітити велике збільшення секції bss.   

![task23.png](practise2/images/task23.png)
Після ініціалізації масив перемістився з bss до секції data, також варто відмітити те що розмір файлу нарешті виріс, адже data на відміну від bss міститься у виконуваному файлі

![task24.png](practise2/images/task24.png)
Додамо ініціалізований та не ініціалізований масив в функцію. Локальні змінні потрапляють в стек  
який не є частиною виконуваного файлу, тому бачимо що розмір схожий до перших значень.

![task25.png](practise2/images/task25.png)
Розглянемо як прапорці оптимізації впливають на розмір виконуваного файлу. Перший  приклад без оптимізації, наступні з -g та -o3 відповідно. Помітимо, що тільки -g незначно вплинув на розмір файлу, а розміри секцій не змінювались взагалі.

## Завдання 3
Реалізовано програму в якій створюються змінні різного виду та відслідковується їх адреса для того щоб отримати приблизну адресу деяких сегментів.

![task3.png](practise2/images/task3.png)
Наприклад можемо помітити як адреса функції мейн більша за адреси масивів визначених в ній, тобто вершина стеку йде до низу. Також помітимо що адреси цих масивів йдуть не в порядку визначення, компілятор розставляє змінні так, як буде краще для оптимізації.

## Завдання 4
Візьмемо код з умови задачі та розглянемо його

![task41.png](practise2/images/task41.png)
Скомпілювали програму з тегом для відлагодження, запустили у фоновому режимі, дізналися PID за допомогоюю echo.

![task42.png](practise2/images/task42.png)
Підключимось до GDB з отриманим process id.
Аналізуючи отриману інформацію, бачимо що на вершині стеку реалізовані в програмі функції, а потім йдуть системи, що викликають паузу.  
main викликала foo.  
foo викликала bar.  
bar викликала bar_is_now_closed.  
bar_is_now_closed викликала pause (яка, в свою чергу, всередині використовує _sigsuspend).  

## Завдання 5
Стек і лічильник команд мають різні функції, тому не можна сказати що можна обійтись без одного з них. Таке було б можливо тільки у випадку найпростіших програм де відсутні цикли і умовні оператори.
В звичайних випадках без IP було б просто не відому яку команду потрібно виконати наступною.

## Завдання 6
Розроблено просту програму з функціями і циклами, які компілятор можливо захоче оптимізувати. При компіляції застосовано прапорец -Os
```shell
gcc -Wall -Os task6.c -o task6
```
Основною ціллю цього прапорця є оптимізація розміру виконуваного файлу, тобто його зменшення. В нашому випадку можливо видалиться не використана функція та вбудується inline функція, можливо оптимізуються цикли.  
Розглянемо як впливає цей прапорець на розмір сегментів і розмір файлу:
![task6.png](practise2/images/task6.png)

Спочатку передивляємось розмір файлу без оптимізації. Звертаємо увагу на розмір файлу та сегменту text: 8688 & 1471 байтів відповідно, а компіляція з -Os бачимо цифри 8464 & 1270 - тобто розмір файлу і text справді зменшились, оптимізація відбулась.
